"use strict";
var cc = require("../dist/index");
var assert = require("assert");
var _ = require("lodash");
var fs = require("fs");
function get_diff_count(text1, text2) {
    var diff_count = 0;
    text1.split("").forEach(function (el, i) {
        if (el != text2[i]) {
            diff_count++;
        }
    });
    return diff_count;
}
var cheeseText = fs.readFileSync("./test/cheese.txt").toString();
function cheeseTest(cipher, solver, stat) {
    var key = cipher.keyInfo.generateRandom();
    var cipherText = cipher.encrypt(cheeseText, key);
    var result = solver.solve({
        cipherText: cipherText,
        cipher: cipher,
        stat: stat,
        reporter: cc.reporters.stdout
    });
    assert(get_diff_count(cheeseText, result.text) < 10);
}
describe("solvers", function () {
    it("solves ceasar shift using brute force", function () {
        assert.equal(cc.solvers.bruteForce.solve({
            cipherText: "Alza zaypun!",
            cipher: cc.ciphers.caesarShift,
            stat: cc.stats.chiSquared,
            reporter: cc.reporters.silentReporter
        }).text, "Test string!");
    });
    xit("solves transposition by simulated annealing", function () {
    });
    xit("solves transposition using hill climbing", function () {
        cheeseTest(cc.ciphers.simpleSubstitution, cc.solvers.hillClimbing, cc.stats.chiSquared);
    });
});
describe("abstract ciphers", function () {
    it("formats and unformats strings", function () {
        assert.equal(cc.util.unformat("Test string!"), "TESTSTRING");
        assert.equal(cc.util.format("TSTSSTRNGY", "Test string!"), "Tsts strngy!");
    });
});
describe("test decrypt", function () {
    it("amsco", function () {
        assert.equal(cc.ciphers.amsco.decrypt("RIHFTUANMRFUHGAC", [3, 5, 1, 2, 4]), "ANGRIFFUMACHTUHR");
    });
});
describe("test encrypt", function () {
    it("amsco", function () {
        assert.equal(cc.ciphers.amsco.encrypt("ANGRIFFUMACHTUHR", [3, 5, 1, 2, 4]), "RIHFTUANMRFUHGAC");
        assert.equal(cc.ciphers.amsco.encrypt("RIDERSONTHESTORMINTOTHISHOUSEWEAREBORNJIMMORRISON", [7, 4, 5, 6, 3, 2, 1]), "HETEAMTTOWIMONNSEJNDTOSEBRERRHOOISSMIURNORISHIROR");
    });
    it("columnar transposition", function () {
        assert.equal(cc.ciphers.columnTransposition.encrypt("WE ARE DISCOVERED. FLEE AT ONCE", [6, 3, 2, 4, 1, 5], { formatResult: false }), "EVLNXACDTXESEAXROFOXDEECXWIREE");
    });
    it("hill cipher", function () {
        assert.equal(cc.ciphers.hillCipher.encrypt("HELP", [3, 3, 2, 5]), "HIAT");
    });
    it("rail fence", function () {
        assert.equal(cc.ciphers.railFence.encrypt("WE ARE DISCOVERED. FLEE AT ONCE", 3, { formatResult: false }), "WECRLTEERDSOEEFEAOCAIVDEN");
    });
});
describe("self-tests:", function () {
    var testString = "test string";
    var notFinishedCiphers = [
        "Playfair"
    ];
    var randomParameters = {
        "ColumnTransposition": [5]
    };
    cc.ciphers.Cipher.allCiphers.forEach(function (cipher) {
        describe(cipher.name, function () {
            var testingFunc = _.includes(notFinishedCiphers, cipher.name) ? xit : it;
            testingFunc("decryption of encryption should be a no-op", function () {
                var randomKey = cipher.keyInfo.generateRandom.call(cipher.keyInfo, randomParameters[cipher.name]);
                assert.equal(cipher.decrypt(cipher.encrypt(testString, randomKey), randomKey), testString);
            });
        });
    });
});
