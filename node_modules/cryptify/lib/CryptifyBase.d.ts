/// <reference types="node" />
import { ReadStream, WriteStream } from 'fs';
import { Cipher, Decipher } from 'crypto';
import { CommandMode, BufferEncoding } from './const/types';
declare class CryptifyBase {
    private readonly files;
    private readonly password;
    private readonly algorithm;
    private readonly encoding;
    private readonly silent;
    private readonly loose;
    private readonly key;
    private iv?;
    private cipher?;
    private mode;
    private returnResults;
    private isModule;
    constructor(files: string[], password: string, algorithm?: string, encoding?: BufferEncoding, silent?: boolean, loose?: boolean);
    /**
     * Set the command mode
     * @param mode
     */
    setMode(mode: CommandMode): void;
    /**
     * Set the isModule flag
     * @param isModule
     */
    setIsModule(isModule: boolean): void;
    /**
     * Set the return results
     * @param returnResults
     */
    setReturnResults(returnResults: boolean): void;
    /**
     * Determine if we're encrypting or decrypting
     * @returns {boolean}
     */
    isEncrypting(): boolean;
    /**
     * Get the verb for the command mode
     * @returns {string}
     */
    getModeVerb(): "Encrypting" | "Decrypting";
    getKey(): Buffer;
    /**
     * Ensure the file exist on the filesystem
     * @param files
     * @private
     */
    validateFiles(files: string[]): void;
    /**
     * Ensure the password meets complexity requirements
     * @param password
     * @private
     */
    validatePassword(password: string): void;
    /**
     * Ensure the cipher is supported by OpenSSL
     * @param algorithm
     * @private
     */
    validateCipherAlgorithm(algorithm: string): void;
    /**
     * Generate a cipher given a cipher algorithm, key and IV
     * @param iv
     * @returns {Cipher | Decipher}
     */
    generateCipher(iv: Buffer): Cipher | Decipher;
    /**
     * Get input/output file paths
     * @param file
     * @returns {{iPath: string, oPath: string}}
     */
    getFilePaths(file: string): {
        iPath: string;
        oPath: string;
    };
    /**
     * Get the encryption streams, and generate a random IV and
     * persist it to the output stream. We'll use the persisted IV
     * during the decryption process.
     * @param file
     * @returns {Promise<{iStream: ReadStream, oStream: WriteStream, iPath: string, oPath: string}>}
     */
    getEncryptionStreams(file: string): Promise<{
        iStream: ReadStream;
        oStream: WriteStream;
        iPath: string;
        oPath: string;
    }>;
    /**
     * Get the decryption streams, and obtain the IV from
     * the encrypted data. Use this persisted IV to generate
     * the cipher for decryption.
     * @param file
     * @returns {Promise<{iStream: ReadStream, oStream: WriteStream, iPath: string, oPath: string}>}
     */
    getDecryptionSteams(file: string): Promise<{
        iStream: ReadStream;
        oStream: WriteStream;
        iPath: string;
        oPath: string;
    }>;
    /**
     * Get the IV that is stored within the encrypted file
     * @param inputPath
     * @returns {Promise<unknown>}
     */
    getIvFromStream(inputPath: string): Promise<Buffer>;
    /**
     * Pipe the input stream into the output stream. During this
     * process we'll either be encrypting or decrypting.
     * @param iStream
     * @param oStream
     * @returns {Promise<unknown>}
     */
    processStream(iStream: ReadStream, oStream: WriteStream): Promise<Error | null>;
    getFilesSync(): string[];
    /**
     * Run the encryption/decryption process
     * @returns {Promise<void>}
     */
    execute(): Promise<string[] | undefined>;
}
export default CryptifyBase;
